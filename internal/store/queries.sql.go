// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package store

import (
	"context"
)

const approveComment = `-- name: ApproveComment :one
update
  comments
set
  approved_at = current_timestamp
where
  approval_code = ?1
returning
  id, lookup_id, user_id, created_at, updated_at, article_slug, published_at, approved_at, approval_code, should_notify, content
`

func (q *Queries) ApproveComment(ctx context.Context, approvalCode string) (Comment, error) {
	row := q.db.QueryRowContext(ctx, approveComment, approvalCode)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.LookupID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ArticleSlug,
		&i.PublishedAt,
		&i.ApprovedAt,
		&i.ApprovalCode,
		&i.ShouldNotify,
		&i.Content,
	)
	return i, err
}

const createComment = `-- name: CreateComment :one
insert into comments (article_slug, user_id, published_at, approval_code, should_notify, content)
  values (?1, ?2, ?3, ?4,
    ?5, ?6)
returning
  id, lookup_id, user_id, created_at, updated_at, article_slug, published_at, approved_at, approval_code, should_notify, content
`

type CreateCommentParams struct {
	ArticleSlug  string
	UserID       int64
	PublishedAt  string
	ApprovalCode string
	ShouldNotify bool
	Content      string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.ArticleSlug,
		arg.UserID,
		arg.PublishedAt,
		arg.ApprovalCode,
		arg.ShouldNotify,
		arg.Content,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.LookupID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ArticleSlug,
		&i.PublishedAt,
		&i.ApprovedAt,
		&i.ApprovalCode,
		&i.ShouldNotify,
		&i.Content,
	)
	return i, err
}

const findCommentsForArticle = `-- name: FindCommentsForArticle :many
select
  c.id,
  c.lookup_id,
  c.created_at,
  c.updated_at,
  c.article_slug,
  c.published_at,
  c.content,
  c.user_id,
  u.email,
  u.name,
  u.should_notify as user_should_notify
from
  comments c
  join users u on u.id = c.user_id
where
  c.article_slug = ?1
  and c.approved_at is not null
order by
  c.published_at
`

type FindCommentsForArticleRow struct {
	ID               int64
	LookupID         string
	CreatedAt        string
	UpdatedAt        string
	ArticleSlug      string
	PublishedAt      string
	Content          string
	UserID           int64
	Email            string
	Name             string
	UserShouldNotify bool
}

func (q *Queries) FindCommentsForArticle(ctx context.Context, slug string) ([]FindCommentsForArticleRow, error) {
	rows, err := q.db.QueryContext(ctx, findCommentsForArticle, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCommentsForArticleRow
	for rows.Next() {
		var i FindCommentsForArticleRow
		if err := rows.Scan(
			&i.ID,
			&i.LookupID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ArticleSlug,
			&i.PublishedAt,
			&i.Content,
			&i.UserID,
			&i.Email,
			&i.Name,
			&i.UserShouldNotify,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
